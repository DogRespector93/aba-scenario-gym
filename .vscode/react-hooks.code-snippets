{
  "useState (value + setter)": {
    "prefix": "us2",
    "description": "useState with [value, setValue]",
    "body": ["const [${1:value}, set${2:Value}] = useState(${3:initial});", ""],
  },

  "useState (object patch merge)": {
    "prefix": "usobj",
    "description": "useState for an object + patch update (merge)",
    "body": [
      "type ${1:State} = {",
      "  ${2:key}: ${3:string};",
      "};",
      "",
      "const [${4:state}, set${5:State}] = useState<${1:State}>({",
      "  ${2:key}: ${6:\"\"},",
      "});",
      "",
      "const patch${1:State} = (patch: Partial<${1:State}>) => {",
      "  set${5:State}(prev => ({ ...prev, ...patch }));",
      "};",
    ],
  },

  "useEffect (subscribe / cleanup)": {
    "prefix": "uec",
    "description": "useEffect with cleanup",
    "body": [
      "useEffect(() => {",
      "  ${1:// setup}",
      "  return () => {",
      "    ${2:// cleanup}",
      "  };",
      "}, [${3:deps}]);",
    ],
  },

  "useEffect (async fetch with AbortController)": {
    "prefix": "uefetch",
    "description": "Async effect pattern with AbortController",
    "body": [
      "useEffect(() => {",
      "  const controller = new AbortController();",
      "  const { signal } = controller;",
      "",
      "  (async () => {",
      "    try {",
      "      ${1:// setLoading(true)}",
      "      const res = await fetch(${2:\"/api/endpoint\"}, { signal });",
      "      if (!res.ok) throw new Error(`HTTP ${res.status}`);",
      "      const data = (await res.json()) as ${3:unknown};",
      "      ${4:// setData(data)}",
      "    } catch (err) {",
      "      if ((err as any)?.name === 'AbortError') return;",
      "      ${5:// setError(err)}",
      "    } finally {",
      "      ${6:// setLoading(false)}",
      "    }",
      "  })();",
      "",
      "  return () => controller.abort();",
      "}, [${7:deps}]);",
    ],
  },

  "useMemo (derived value)": {
    "prefix": "umemo",
    "description": "useMemo derived value",
    "body": [
      "const ${1:derived} = useMemo(() => {",
      "  return ${2:expression};",
      "}, [${3:deps}]);",
    ],
  },

  "useCallback (stable handler)": {
    "prefix": "ucb",
    "description": "useCallback handler",
    "body": [
      "const ${1:onThing} = useCallback((${2:arg}: ${3:type}) => {",
      "  ${4:// ...}",
      "}, [${5:deps}]);",
    ],
  },

  "Upsert into array by id": {
    "prefix": "upsertid",
    "description": "Upsert an item into an array by key",
    "body": [
      "type ${1:Item} = { id: string; ${2:/* other fields */} };",
      "",
      "const upsertById = (items: ${1:Item}[], next: ${1:Item}): ${1:Item}[] => {",
      "  const index = items.findIndex(item => item.id === next.id);",
      "  if (index === -1) return [...items, next];",
      "  return items.map(item => (item.id === next.id ? next : item));",
      "};",
      "",
      "// usage with setState:",
      "// setItems(prev => upsertById(prev, nextItem));",
    ],
  },

  "Reducer (action union + switch)": {
    "prefix": "rdxmini",
    "description": "Small useReducer template with action union",
    "body": [
      "type ${1:State} = {",
      "  ${2:count}: number;",
      "};",
      "",
      "type ${3:Action} =",
      "  | { type: '${4:increment}' }",
      "  | { type: '${5:reset}' };",
      "",
      "const initial${1:State}: ${1:State} = { ${2:count}: 0 };",
      "",
      "function ${6:reducer}(state: ${1:State}, action: ${3:Action}): ${1:State} {",
      "  switch (action.type) {",
      "    case '${4:increment}':",
      "      return { ...state, ${2:count}: state.${2:count} + 1 };",
      "    case '${5:reset}':",
      "      return initial${1:State};",
      "    default:",
      "      return state;",
      "  }",
      "}",
      "",
      "const [state, dispatch] = useReducer(${6:reducer}, initial${1:State});",
      "",
      "// dispatch({ type: '${4:increment}' });",
    ],
  },
}
